function M = LucasKanadeAffine(It, It1)

% input - image at time t, image at t+1 
% output - M affine transformation matrix

% initialize the coordinates and threshold
[It, It1] = deal(im2double(It), im2double(It1));
[height width] = deal(size(It, 1), size(It, 2));

% image vector generation
[X, Y] = meshgrid(1: ceil(width), 1: ceil(height));
[X, Y] = deal(X(:), Y(:));
imgVec = [X'; Y'; ones(size(X'))];

% iteratively minimize error
converge = false;
while converge ~= true
   
    % affine transformation matrix
    M = [1+p(1), p(3), p(5); p(2), 1+p(4), p(6); 0, 0, 1];
    
    % warp and compute error image, update p 
    warpedIt = warpH(It, M, size(It)); 
%     [X1, Y1] = meshgrid(x1+p(1): ceil(x2+p(1)), y1+p(2): ceil(y2+p(2)));
%     corr = [x1+p(1), x2+p(1), y1+p(2), y2+p(2)];

    errorImg = It1 - warpedIt;
    [Fx, Fy] = gradient(warpedIt);

    % matrix of image derivatives
    A = [Fx(:) .* X, Fx(:) .* Y, Fx(:) .* Y, Fy(:) .* Y, Fx, Fy];
    H = 
    
    delta = H \ ([Fx(:), Fy(:)]' * errorImg(:));
    p = p - delta;
    converge = norm(delta) < threshold;
end 

[u v] = deal(p(1), p(2));

end

